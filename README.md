# MongoDB
Mongo Basic knowledge

## MongoDB 基础知识

## MongoDB 与 Noql 和 关系型数据库异同

## MongoDB 与 Redis、ufile、ufs、memCashed、CouchDB等区别

## MongoDB 读写分离方案

## MongoDB 性能与优化

## MongoDB 设计模式与适应场景
    > 1. 设计模式
        mongo是一个高可用、分布式、灵活模式的文档数据库。一般建议的是先考虑内嵌，但是有一些时候，使用引用则难以避免。
    > 2. 适用场景
        (1).  适合实时的插入，更新与查询，并具备应用程序实时数据存储所需的复制及高度伸缩性。

         	◆网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。

        (2).  适合作为信息基础设施的持久化缓存层。

         	◆缓存：由于性能很高，Mongo也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo搭建的持久化缓存层可以避免下层的数据源过载。

         	◆大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵

        (3).  适合由数十或数百台服务器组成的数据库。因为Mongo已经包含对MapReduce引擎的内置支持。

         	◆高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。

        (4).  Mongo的BSON数据格式非常适合文档化格式的存储及查询。

         	◆用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询
    > 3. 不适场景

        (1).  高度事务性的系统。

    	    ◆高度事务性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。

        (2).  传统的商业智能应用。

    	    ◆传统的商业智能应用：针对特定问题的BI数据库会对产生高度优化的查询方式。对于此类应用,数据仓库可能是更合适的选择。

        (3).  复杂的SQL查询。

          	◆需要SQL的问题

    > 4. 针对某些MongoDB不适用的场合，有时可选用设计模式来加以应对。

        （1）. 查询命令分离模式

        	在副本集中职责被分离到不同的节点。最基本的第一类节点可能也同时占据着首要地位，它只需要储存那些写入和更新所需的数据。而查询工作则交由第二类节点来执行。这一模式将提升首要节点服务器的写吞吐量，因为当写入一组对象时，需要更新及插入的数据量也随之减少，除此之外，二类节点也得益于较少的待更新数据和其自身所具有的为其工作量而优化的内存工作集。

        （2）. 应用程序级事务模式

        	MongoDB不支持事务和文件内部锁定。

        （3）. Bucketing模式

        	当文本含有一个不断增长的数组时，则使用Bucketing模式，例如指令。而指令线可能会扩展到超过文档大小的合理值。该模式经由编程方式处理，并通过公差计算触发。

        （4）. 关系模式

        	有时，会有不能插入整个文档的情况，例如人体建模时，我们就可以使用该模式来建立关系。
        
        		* 确定数据是否属于该文档，即二者间是否有关系。
        		* 如果可能的话，特别是面对有用的独有（专属）数据时，插入文档。
        		* 尽可能不参考id值。
        		* 对关系中的有用部分进行反规范化处理。好的候选不会经常甚至从不更改值，并且颇为有用。
        		* 关注反规范数据的更新和关系修复。

        （5）. 物化路径模式

        	在一个数据模型的树模式中，同一对象类型是该对象的子对象，这种情况下可以使用物化路径模型来以获取更高效的检索、查询。


## MongoDB 局限与不足
